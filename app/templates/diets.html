{% extends "base.html" %}

{% block content %}
      <main class="app-main">
        <style>
          [x-cloak] {
            display: none;
          }
          #diet-items-head .is-hidden-col,
          #diet-items-body .is-hidden-col {
            display: none;
          }
          #diet-items-body .color-swatch {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 1px solid rgba(0, 0, 0, 0.2);
            display: inline-block;
          }
          #diet-items-body .color-dropdown {
            position: relative;
            display: inline-flex;
            align-items: center;
          }
          #diet-items-body .color-menu {
            position: absolute;
            top: calc(100% + 0.25rem);
            left: 0;
            z-index: 10;
            display: none;
            grid-template-columns: repeat(3, 18px);
            gap: 0.35rem;
            padding: 0.5rem;
            background: var(--bs-body-bg);
            border: 1px solid var(--bs-border-color);
            border-radius: 0.4rem;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.2);
          }
          #diet-items-body .color-dropdown.is-open .color-menu {
            display: grid;
          }
          #diet-items-body .color-swatch.is-selected {
            outline: 1px solid var(--bs-body-color);
          }
          #diet-items-body .food-picker {
            position: relative;
            z-index: 50;
          }

          #diet-items-table th.name-col, #diet-items-table td.name-col {
            width: 200px;
            min-width: 200px;
            /* position: sticky;
            left: 0;
            z-index: 2; */
          }

          #diet-items-body .food-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 200;
            max-height: 220px;
            overflow: auto;
            background: var(--bs-body-bg);
            border: 1px solid var(--bs-border-color);
            border-radius: 0.25rem;
            min-width: 260px;
          }
          #diet-items-body .food-option {
            padding: 0.25rem 0.5rem;
            cursor: pointer;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 260px;
          }
          #diet-items-body .food-option:hover {
            background: var(--bs-secondary-bg);
          }
          #diet-items-body tr > td {
            background-color: inherit;
          }
          #diet-items-table th.name-col,
          #diet-items-table td.name-col,
          #diet-items-table th.quantity-col,
          #diet-items-table td.quantity-col {
            overflow: visible;
          }
          #diet-items-body td.name-col.is-open,
          #diet-items-body td.quantity-col.is-open {
            z-index: 200;
          }

          #diet-items-body .totals-row .totals-highlight {
            font-weight: 600;
          }
          #diet-items-body .totals-row .totals-protein {
            background-color: var(--food-dominant-protein);
            font-weight: 600;
          }
          #diet-items-body .totals-row .totals-carb {
            background-color: var(--food-dominant-carb);
            font-weight: 600;
          }
          #diet-items-body .totals-row .totals-fat {
            background-color: var(--food-dominant-fat);
            font-weight: 600;
          }

          .diet-name-editor .diet-name-input {
            max-width: 360px;
          }

          .table-responsive {
            overflow: visible !important;
          }

          #diet-items-table {
            table-layout: fixed;
            min-width: 2800px;
          }

          #diet-items-table #diet-items-body tr {
            background-color: var(--bs-body-bg)
          }

          #diet-items-table th.name-col, #diet-items-table td.name-col {
            width: 200px;
            min-width: 200px;
            position: sticky;
            left: 0;
            z-index: 2;
          }

          #diet-items-table th.quantity-col, #diet-items-table td.quantity-col {
            width: 80px;
            min-width: 80px;
            position: sticky;
            left: 200px;
            z-index: 1;
          }
        </style>
        <!--begin::App Content Header-->
        <div class="app-content-header">
          <!--begin::Container-->
          <div class="container-fluid">
            <!--begin::Row-->
            <div class="row">
              <div class="col-sm-6">
                <div class="diet-name-editor" id="diet-name-editor" x-data="dietNameEditor()">
                  <h3
                    class="mb-0 diet-name-display"
                    id="diet-name-heading"
                    x-show="!isEditing"
                    x-text="diet_name"
                    x-on:click="isEditing = true"
                  >
                    
                  </h3>
                  <input
                    class="form-control form-control-sm diet-name-input"
                    id="diet-name-input"
                    type="text"
                    value="{{ diet_name }}"
                    aria-label="diet name"
                    x-show="isEditing"
                    x-model="diet_name"
                    x-on:blur="saveDietName()"
                  />
                </div>
              </div>
            </div>
            <!--end::Row-->
          </div>
          <!--end::Container-->
        </div>
        <!--end::App Content Header-->
        <!--begin::App Content-->
        <div class="app-content">
          <!--begin::Container-->
          <div class="container-fluid">
            <!--begin::Row-->
            <div class="row">
              <div class="col-12">
                <div class="card" x-data>
                  <div class="card-body">
                    <div class="d-flex flex-wrap align-items-center gap-2 mb-3">
                      <button id="diet-items-add" type="button" class="btn btn-outline-primary btn-sm" @click="$store.diet.addItem({ dietName: $store.diet.dietName })">
                        Add Item
                      </button>
                      <button id="diet-items-save-all" type="button" class="btn btn-success btn-sm d-none">
                        Save All
                      </button>
                      <div id="diet-items-status" class="text-muted small"></div>
                      <div id="diet-items-hash" class="text-muted small"></div>
                      <div class="flex-grow-1"></div>
                      <button id="diet-items-clone" type="button" class="btn btn-outline-success btn-sm" @click="$store.diet.cloneDiet()">
                        Clone diet
                      </button>
                      <button id="diet-items-delete-all" type="button" class="btn btn-outline-danger btn-sm" @click="$store.diet.deleteAllDietItems()">
                        Delete All
                      </button>
                    </div>
                    <div class="table-responsive">
                      <table
                        class="table table-sm table-bordered align-middle mb-0"
                        id="diet-items-table"
                        @click.outside="$store.diet.stopEdit()"
                        @click="
                          if ($store.diet.isEditing) {
                            const cell = $event.target.closest('td');
                            if (!cell || !(cell.classList.contains('name-col') || cell.classList.contains('quantity-col') || cell.classList.contains('color-col') || cell.classList.contains('dietItemDel-col'))) {
                              $store.diet.stopEdit();
                            }
                          }
                        "
                        @keydown.enter.prevent="$store.diet.stopEdit(true)"
                        @keydown.escape.prevent="$store.diet.stopEdit(true)"
                      >
                        <thead id="diet-items-head">
                          <tr>
                            <th x-show="$store.diet.isEditing"></th>
                            <template x-for="col in $store.diet.columns" :key="col">
                              <th
                                :class="{
                                  'is-hidden-col': $store.diet.isHidden(col),
                                  'name-col': col === 'Name',
                                  'quantity-col': col === 'quantity',
                                  'color-col': col === 'color'
                                }"
                                x-text="col"
                              ></th>
                            </template>
                          </tr>
                        </thead>
                        <tbody id="diet-items-body" x-init="$store.diet.initSortable($el)">
                          <template x-for="row in $store.diet.dietItemNutritionList" :key="row._rowKey">
                            <tr :style="$store.diet.rowStyle(row)" :data-row-key="row._rowKey">
                              <td x-show="$store.diet.isEditing" class="dietItemDel-col" @click="$store.diet.startEdit(row)">
                                <button
                                  type="button"
                                  class="btn btn-outline-danger btn-sm"
                                  @click="$store.diet.deleteRow(row)"
                                >
                                  Delete
                                </button>
                              </td>
                              <template x-for="col in $store.diet.columns" :key="col">
                                <td
                                  :class="{
                                    'is-hidden-col': $store.diet.isHidden(col),
                                    'name-col': col === 'Name',
                                    'quantity-col': col === 'quantity',
                                    'color-col': col === 'color',
                                    'is-open': col === 'Name' && $store.diet.isFoodPickerFocused(row)
                                  }"
                                  :style="$store.diet.rowStyle(row, col)"
                                  @click="(col === 'Name' || col === 'quantity' || col === 'color') && $store.diet.startEdit(row)"
                                >
                                  <template x-if="col === 'color'">
                                    <div class="color-dropdown" :class="{ 'is-open': $store.diet.isColorMenuOpen(row) }">
                                      <button
                                        type="button"
                                        class="btn btn-sm color-toggle"
                                        @click.stop="$store.diet.startEdit(row); $store.diet.toggleColorMenu(row)"
                                      >
                                        <i class="bi bi-eyedropper"></i>
                                      </button>
                                      <div class="color-menu">
                                        <template x-for="swatch in $store.diet.getColorSwatches()" :key="swatch">
                                          <span
                                            class="color-swatch"
                                            :class="{ 'is-selected': String(row[col] || '').toLowerCase() === swatch.toLowerCase() }"
                                            :style="`background:${swatch}`"
                                            @click="$store.diet.isEditingRow(row) && $store.diet.dietItemNutritionUpdate(row, { color: swatch })"
                                          ></span>
                                        </template>
                                      </div>
                                    </div>
                                  </template>
                                  <template x-if="col !== 'color'">
                                    <div x-show="!($store.diet.isEditingRow(row) && (col === 'Name' || col === 'quantity'))" x-text="row[col]"></div>
                                  </template>
                                  <template x-if="col === 'Name'">
                                    <div class="food-picker">
                                      <input
                                        x-cloak
                                        x-show="$store.diet.isEditingRow(row)"
                                        type="text"
                                        class="form-control form-control-sm mt-1 food-name-input"
                                        :value="$store.diet.getEditValue(row, 'Name')"
                                        @input="$store.diet.dietItemNutritionUpdate(row, { nameInput: $event.target.value })"
                                        @focus="$store.diet.setFoodPickerFocus(row, true)"
                                        @blur="$store.diet.setFoodPickerFocus(row, false)"
                                        @keydown.enter.prevent="$store.diet.stopEdit()"
                                        @keydown.escape.prevent="$store.diet.stopEdit()"
                                      >
                                      <div
                                        class="food-options"
                                        x-cloak
                                        @mousedown.prevent
                                        x-show="$store.diet.isEditingRow(row) && $store.diet.hasFoodOptions(row) && $store.diet.isFoodPickerFocused(row)"
                                      >
                                        <template x-for="food in $store.diet.getFoodOptions(row)" :key="food.fdc_id">
                                          <div
                                            class="food-option"
                                            @click="$store.diet.dietItemNutritionUpdate(row, { food })"
                                            x-text="food.Name"
                                          ></div>
                                        </template>
                                      </div>
                                    </div>
                                  </template>
                                  <template x-if="col === 'quantity'">
                                    <input
                                      x-cloak
                                      x-show="$store.diet.isEditingRow(row)"
                                      type="number"
                                      class="form-control form-control-sm mt-1"
                                      :value="$store.diet.getEditValue(row, 'quantity')"
                                      @input="$store.diet.dietItemNutritionUpdate(row, { quantity: $event.target.value })"
                                      @keydown.enter.prevent="$store.diet.stopEdit()"
                                      @keydown.escape.prevent="$store.diet.stopEdit()"
                                    >
                                  </template>
                                </td>
                              </template>
                            </tr>
                          </template>
                          <template x-if="$store.diet.showTotalsRow()">
                            <tr class="totals-row">
                              <td x-show="$store.diet.isEditing"></td>
                              <template x-for="col in $store.diet.columns" :key="`totals-${col}`">
                                <td
                                  :class="$store.diet.getTotalsCellClass(col)"
                                  x-html="$store.diet.getTotalsCellHtml(col)"
                                ></td>
                              </template>
                            </tr>
                          </template>
                          <template x-if="$store.diet.showRdaRow()">
                            <tr class="totals-row">
                              <td x-show="$store.diet.isEditing"></td>
                              <template x-for="col in $store.diet.columns" :key="`rda-${col}`">
                                <td
                                  :class="$store.diet.getRdaCellClass(col)"
                                  x-html="$store.diet.getRdaCellHtml(col)"
                                ></td>
                              </template>
                            </tr>
                          </template>
                          <template x-if="$store.diet.showUlRow()">
                            <tr class="totals-row">
                              <td x-show="$store.diet.isEditing"></td>
                              <template x-for="col in $store.diet.columns" :key="`ul-${col}`">
                                <td
                                  :class="$store.diet.getUlCellClass(col)"
                                  x-html="$store.diet.getUlCellHtml(col)"
                                ></td>
                              </template>
                            </tr>
                          </template>
                        </tbody>
                      </table>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!--end::Container--> 
        </div>
        <!--end::App Content-->
        <div class="msg-toast" role="status" aria-live="polite">
          <i class="bi bi-check-circle-fill" aria-hidden="true"></i>
          <span>Updated</span>
        </div>
      </main>

<script>
    document.addEventListener('alpine:init', () => {

        Alpine.data('dietNameEditor', () => ({
            diet_name: "{{ diet_name }}",
            isEditing: false,
            saveDietName() {
              const dietStore = Alpine.store('diet');
              const newName = (this.diet_name || "").trim();
              if (!newName || newName === dietStore.dietName) {
                this.diet_name = dietStore.dietName || this.diet_name;
                this.isEditing = false;
                return;
              }
              const status = document.getElementById("diet-items-status");
              if (status) status.textContent = "Saving diet name...";
              fetch("/api/diet/name_only", {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  diet_name_old: dietStore.dietName,
                  diet_name_new: newName
                })
              })
                .then((response) => {
                  if (!response.ok) {
                    throw new Error(`Request failed with ${response.status}`);
                  }
                  dietStore.dietName = newName;
                  dietStore.dietItemNutritionList = dietStore.dietItemNutritionList.map((item) => ({
                    ...item,
                    diet_name: newName
                  }));
                  const params = new URLSearchParams(window.location.search);
                  params.set("diet_name", newName);
                  const newUrl = `${window.location.pathname}?${params.toString()}`;
                  window.history.replaceState({}, "", newUrl);
                  loadDietSidebar();
                })
                .catch((error) => {
                  if (status) {
                    status.textContent = `Failed to save diet name: ${error.message}`;
                  }
                  this.diet_name = dietStore.dietName;
                })
                .finally(() => {
                  this.isEditing = false;
                  if (status) status.textContent = "";
                });
            }
        }));

        Alpine.store('diet', {
            dietItemNutritionList: [],
            columns: [],
            hiddenCols: ['diet_name', 'fdc_id', 'sort_order', 'Energy kJ', 'color'],
            foodsMap: {},
            foodsList: [],
            dietName: "",
            rdaByNutrient: {},
            ulByNutrient: {},
            hideRdaUlValues: false,
            rdaThreshold: null,
            ulThreshold: null,
            isEditing: false,
            editingKey: null,
            colorMenuKey: null,
            editValues: {},
            sortable: null,
            focusedFoodPickerKey: null,
            getColorSwatches() {
              return localStorage.getItem("theme") === "light"
                ? ["#d86a6b", "#d68a5a", "#d6b46a", "#8cc26a", "#6bb59c", "#7aa0b5"]
                : ["#971d1f", "#ad5322", "#af882e", "#538d28", "#2b8066", "#375875"];
            },
            rowKey(row) {
              return row._rowKey;
            },
            showTotalsRow() {
              return this.columns.includes("Energy kcal");
            },
            showRdaRow() {
              return this.showTotalsRow() && Object.keys(this.rdaByNutrient).length > 0;
            },
            showUlRow() {
              return this.showTotalsRow() && Object.keys(this.ulByNutrient).length > 0;
            },
            getColumnTotal(col) {
              let total = 0;
              this.dietItemNutritionList.forEach((item) => {
                const value = item[col];
                if (typeof value === "number" && Number.isFinite(value)) {
                  total += value;
                } else if (typeof value === "string" && value.trim() !== "" && !Number.isNaN(Number(value))) {
                  total += Number(value);
                }
              });
              return total;
            },
            getRdaWarnings() {
              if (!Number.isFinite(this.rdaThreshold)) return {};
              const warnings = {};
              this.columns.forEach((col) => {
                const rdaValue = this.rdaByNutrient[String(col || "").trim()];
                if (Number.isFinite(rdaValue) && rdaValue > 0) {
                  const total = this.getColumnTotal(col);
                  const rdaPercent = Math.round((total / rdaValue) * 100);
                  if (rdaPercent < this.rdaThreshold) {
                    warnings[col] = true;
                  }
                }
              });
              return warnings;
            },
            getUlWarnings() {
              if (!Number.isFinite(this.ulThreshold)) return {};
              const warnings = {};
              this.columns.forEach((col) => {
                const ulValue = this.ulByNutrient[String(col || "").trim()];
                if (Number.isFinite(ulValue) && ulValue > 0) {
                  const total = this.getColumnTotal(col);
                  const ulPercent = Math.round((total / ulValue) * 100);
                  if (ulPercent > this.ulThreshold) {
                    warnings[col] = true;
                  }
                }
              });
              return warnings;
            },
            getTotalsCellHtml(col) {
              if (col === "diet_name" || col === "fdc_id" || col === "sort_order" || col === "Energy kJ") {
                return "";
              }
              if (col === "color") return "";
              if (col === "Name") return "Totals";
              if (col === "quantity" || col === "Unit") return "";
              const total = this.getColumnTotal(col);
              const roundedTotal = total.toFixed(2);
              if (col === "Price") {
                return `$${roundedTotal}  `;
              }
              if (col === "Energy kcal") {
                return `${roundedTotal} âš¡`;
              }
              if (col === "Protein g" || col === "Carbohydrate, by difference g" || col === "Total lipid (fat) g") {
                const kcalPerGram = col === "Total lipid (fat) g" ? 9 : 4;
                const percent = Math.round((total * kcalPerGram) / 2000 * 100);
                return `${roundedTotal}<br>(${percent}%)`;
              }
              return roundedTotal;
            },
            getTotalsCellClass(col) {
              const classes = [];
              if (this.isHidden(col)) classes.push("is-hidden-col");
              if (col === "Name") classes.push("name-col");
              if (col === "quantity") classes.push("quantity-col");
              if (col === "color") classes.push("color-col");
              const highlightTotals = new Set([
                "Price",
                "Energy kcal",
                "Protein g",
                "Total lipid (fat) g",
                "Carbohydrate, by difference g"
              ]);
              const totalsColorClass = {
                "Protein g": "totals-protein",
                "Total lipid (fat) g": "totals-fat",
                "Carbohydrate, by difference g": "totals-carb"
              };
              if (highlightTotals.has(col)) {
                classes.push("totals-highlight");
                if (totalsColorClass[col]) {
                  classes.push(totalsColorClass[col]);
                }
              }
              const rdaWarnings = this.getRdaWarnings();
              const ulWarnings = this.getUlWarnings();
              if (rdaWarnings[col]) classes.push("text-warning");
              if (ulWarnings[col]) classes.push("text-danger");
              return classes.join(" ");
            },
            getRdaCellHtml(col) {
              if (col === "diet_name" || col === "fdc_id" || col === "sort_order" || col === "Energy kJ") {
                return "";
              }
              if (col === "color") return "";
              if (col === "Name") return "RDA %";
              if (col === "quantity" || col === "Unit") return "";
              const total = this.getColumnTotal(col);
              const rdaValue = this.rdaByNutrient[String(col || "").trim()];
              if (Number.isFinite(rdaValue) && rdaValue > 0) {
                const rdaPercent = Math.round((total / rdaValue) * 100);
                return this.hideRdaUlValues ? `${rdaPercent}%` : `${rdaValue}<br>${rdaPercent}%`;
              }
              return "";
            },
            getRdaCellClass(col) {
              const classes = [];
              if (this.isHidden(col)) classes.push("is-hidden-col");
              if (col === "Name") classes.push("name-col");
              if (col === "quantity") classes.push("quantity-col");
              if (col === "color") classes.push("color-col");
              const warnings = this.getRdaWarnings();
              if (warnings[col]) classes.push("text-warning");
              return classes.join(" ");
            },
            getUlCellHtml(col) {
              if (col === "diet_name" || col === "fdc_id" || col === "sort_order" || col === "Energy kJ") {
                return "";
              }
              if (col === "color") return "";
              if (col === "Name") return "Upper Limit (UL) %";
              if (col === "quantity" || col === "Unit") return "";
              const total = this.getColumnTotal(col);
              const ulValue = this.ulByNutrient[String(col || "").trim()];
              if (Number.isFinite(ulValue) && ulValue > 0) {
                const ulPercent = Math.round((total / ulValue) * 100);
                return this.hideRdaUlValues ? `${ulPercent}%` : `${ulValue}<br>${ulPercent}%`;
              }
              return "";
            },
            getUlCellClass(col) {
              const classes = [];
              if (this.isHidden(col)) classes.push("is-hidden-col");
              if (col === "Name") classes.push("name-col");
              if (col === "quantity") classes.push("quantity-col");
              if (col === "color") classes.push("color-col");
              const warnings = this.getUlWarnings();
              if (warnings[col]) classes.push("text-danger");
              return classes.join(" ");
            },
            isHidden(col) {
              if (col === "color" && this.isEditing) {
                return false;
              }
              return this.hiddenCols.includes(col);
            },
            startEdit(row) {
              const nextKey = this.rowKey(row);
              this.isEditing = true;
              if (this.editingKey !== nextKey) {
                this.colorMenuKey = null;
              }
              this.editingKey = nextKey;
              if (!this.editValues[this.editingKey]) {
                this.editValues[this.editingKey] = {
                  Name: row.Name ?? "",
                  quantity: row.quantity ?? ""
                };
              }
            },
            stopEdit(shouldFocus = false) {
              this.isEditing = false;
              this.editingKey = null;
              this.colorMenuKey = null;
              this.focusedFoodPickerKey = null;
              if (shouldFocus) {
                document.activeElement.blur();
                document.body.focus({ preventScroll: true });
              }
            },
            isEditingRow(row) {
              return this.isEditing && this.editingKey === this.rowKey(row);
            },
            ensureRowKeys(list) {
              return list.map((item, index) => {
                if (item._rowKey) {
                  return item;
                }
                return { ...item, _rowKey: `${item.diet_name}-${item.fdc_id}-${item.sort_order}-${index}` };
              });
            },
            initSortable(el) {
              if (!window.Sortable || !el) {
                return;
              }
              if (this.sortable) {
                this.sortable.destroy();
              }
              this.sortable = new Sortable(el, {
                animation: 150,
                filter: "input,select,button,.food-options",
                preventOnFilter: false,
                onEnd: () => {
                  this.reorderFromDom(el);
                }
              });
            },
            reorderFromDom(el) {
              if (!el) return;
              this.stopEdit();
              const keyOrder = Array.from(el.children)
                .map((row) => row.dataset.rowKey)
                .filter(Boolean);
              const byKey = new Map(this.dietItemNutritionList.map((item) => [item._rowKey, item]));
              const updates = [];
              const newList = keyOrder.map((key, index) => {
                const item = byKey.get(key);
                if (!item) return null;
                const nextSort = index + 1;
                if (Number(item.sort_order) !== nextSort) {
                  updates.push({ item, originalSort: item.sort_order, nextSort });
                  return { ...item, sort_order: nextSort };
                }
                return item;
              }).filter(Boolean);
              this.dietItemNutritionList = [];
              queueMicrotask(() => {
                this.dietItemNutritionList = newList;
              });
              updates.forEach((entry) => {
                const item = entry.item;
                fetch("/api/diet", {
                  method: "PUT",
                  headers: { "Content-Type": "application/json" },
                  credentials: "same-origin",
                  body: JSON.stringify({
                    diet_name: item.diet_name,
                    fdc_id: item.fdc_id,
                    quantity: item.quantity,
                    sort_order: entry.nextSort,
                    color: item.color ?? null,
                    original_fdc_id: item.fdc_id,
                    original_quantity: item.quantity,
                    original_sort_order: entry.originalSort
                  })
                }).catch((error) => {
                  console.error("Reorder update failed:", error);
                });
              });
            },
            setFoodPickerFocus(row, isFocused) {
              const key = this.rowKey(row);
              this.focusedFoodPickerKey = isFocused ? key : null;
            },
            isFoodPickerFocused(row) {
              return this.focusedFoodPickerKey === this.rowKey(row);
            },
            isColorMenuOpen(row) {
              return this.colorMenuKey === this.rowKey(row);
            },
            toggleColorMenu(row) {
              const key = this.rowKey(row);
              this.colorMenuKey = this.colorMenuKey === key ? null : key;
            },
            getEditValue(row, field) {
              const key = this.rowKey(row);
              return this.editValues[key]?.[field] ?? row[field] ?? "";
            },
            dietItemNutritionUpdate(row, { nameInput, quantity, color, food } = {}) {
              if (!row) return;
              const originalFdcId = row.fdc_id;
              const originalQuantity = row.quantity;
              const originalSortOrder = row.sort_order;
              const key = this.rowKey(row);
              if (!this.editValues[key]) {
                this.editValues[key] = {};
              }
              const dietItem = {
                diet_name: row.diet_name,
                fdc_id: row.fdc_id,
                quantity: row.quantity,
                sort_order: row.sort_order,
                color: row.color ?? null
              };

              if (nameInput !== undefined) {
                this.editValues[key].Name = nameInput;
              }
              if (quantity !== undefined) {
                this.editValues[key].quantity = quantity;
                const parsed = Number(quantity);
                if (Number.isFinite(parsed)) {
                  dietItem.quantity = parsed;
                }
              }
              if (color !== undefined) {
                dietItem.color = color;
              }

              let selectedFood = food || null;
              if (!selectedFood && nameInput) {
                const q = String(nameInput).trim().toLowerCase();
                selectedFood = this.foodsList.find((item) => String(item?.Name || "").toLowerCase() === q) || null;
              }
              if (selectedFood) {
                dietItem.fdc_id = selectedFood.fdc_id;
                this.editValues[key].Name = selectedFood.Name || "";
              }

              const nutritionFood = selectedFood || this.foodsMap[dietItem.fdc_id];
              if (!nutritionFood) return;
              const nextRow = calculateDietNutrition(nutritionFood, dietItem);
              if (color !== undefined) {
                nextRow.color = color;
              }
              if (selectedFood) {
                nextRow.Name = selectedFood.Name || nextRow.Name;
              }
              if (Number.isFinite(dietItem.quantity)) {
                nextRow.quantity = dietItem.quantity;
              }
              nextRow._rowKey = row._rowKey;
              this.replaceNutritionRow(row, nextRow);
              if (color !== undefined) {
                this.colorMenuKey = null;
              }

              fetch("/api/diet", {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                credentials: "same-origin",
                body: JSON.stringify({
                  diet_name: dietItem.diet_name,
                  fdc_id: dietItem.fdc_id,
                  quantity: dietItem.quantity,
                  sort_order: dietItem.sort_order,
                  color: dietItem.color ?? null,
                  original_fdc_id: originalFdcId,
                  original_quantity: originalQuantity,
                  original_sort_order: originalSortOrder
                })
              }).catch((error) => {
                console.error("Update failed:", error);
              });
            },
            getFoodOptions(row) {
              const q = String(this.getEditValue(row, "Name") || "").trim().toLowerCase();
              if (!q) {
                return this.foodsList;
              }
              return this.foodsList.filter((food) => {
                const name = String(food?.Name || "").toLowerCase();
                return name.includes(q);
              });
            },
            hasFoodOptions(row) {
              return this.getFoodOptions(row).length > 0;
            },
            replaceNutritionRow(row, nextRow) {
              const key = this.rowKey(row);
              this.dietItemNutritionList = this.dietItemNutritionList.map((item) => {
                return item._rowKey === key ? nextRow : item;
              });
            },
            deleteRow(row) {
              if (!row) return;
              fetch("/api/diet", {
                method: "DELETE",
                headers: { "Content-Type": "application/json" },
                credentials: "same-origin",
                body: JSON.stringify({
                  diet_name: row.diet_name,
                  fdc_id: row.fdc_id,
                  quantity: row.quantity,
                  sort_order: row.sort_order
                })
              })
                .then((response) => {
                  if (!response.ok) {
                    throw new Error(`Request failed with ${response.status}`);
                  }
                  return response.json();
                })
                .then(() => {
                  this.dietItemNutritionList = this.dietItemNutritionList.filter(
                    (item) => !(item.fdc_id === row.fdc_id && item.sort_order === row.sort_order)
                  );
                })
                .catch((error) => {
                  console.error("Delete failed:", error);
                });
            },
            addItem({ dietName, fdcId = 170567, quantity = 100, color = null } = {}) {
              if (!dietName) return;
              const maxSort = this.dietItemNutritionList.reduce((acc, item) => {
                const value = Number(item?.sort_order);
                return Number.isFinite(value) ? Math.max(acc, value) : acc;
              }, 0);
              const nextSort = maxSort + 1;
              const payload = {
                diet_name: dietName,
                fdc_id: fdcId,
                quantity: quantity,
                sort_order: nextSort,
                color: color
              };
              fetch("/api/diet", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                credentials: "same-origin",
                body: JSON.stringify(payload)
              })
                .then((response) => {
                  if (!response.ok) {
                    throw new Error(`Request failed with ${response.status}`);
                  }
                  return response.json();
                })
                .then(() => {
                  const food = this.foodsMap[payload.fdc_id];
                  const nextRow = food ? calculateDietNutrition(food, payload) : { ...payload };
                  nextRow._rowKey = `${payload.diet_name}-${payload.fdc_id}-${payload.sort_order}-${Date.now()}`;
                  this.dietItemNutritionList = [...this.dietItemNutritionList, nextRow];
                })
                .catch((error) => {
                  console.error("Add diet item failed:", error);
                });
            },
            cloneDiet() {
              if (!this.dietName) {
                const status = document.getElementById("diet-items-status");
                if (status) status.textContent = "Missing diet name for cloning.";
                return;
              }
              const itemsToClone = this.dietItemNutritionList.map((item) => ({
                diet_name: `${this.dietName}_Cloned_${Date.now()}`,
                fdc_id: item.fdc_id,
                quantity: item.quantity,
                sort_order: item.sort_order,
                color: item.color ?? null
              }));
              const cloneName = itemsToClone[0]?.diet_name;
              const status = document.getElementById("diet-items-status");
              const cloneBtn = document.getElementById("diet-items-clone");
              if (itemsToClone.length === 0) {
                if (status) status.textContent = `No items to clone from ${this.dietName}.`;
                return;
              }
              if (cloneBtn) cloneBtn.disabled = true;
              if (status) status.textContent = `Cloning ${this.dietName}...`;
              Promise.all(
                itemsToClone.map((payload) =>
                  fetch("/api/diet", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload)
                  })
                )
              )
                .then((responses) => {
                  const failed = responses.filter((response) => !response.ok);
                  if (failed.length > 0) {
                    throw new Error(`Failed to clone ${failed.length} item(s).`);
                  }
                  window.location.href = `/ui/diets?diet_name=${encodeURIComponent(cloneName)}`;
                })
                .catch((error) => {
                  if (status) status.textContent = `Failed to clone diet: ${error.message}`;
                })
                .finally(() => {
                  if (cloneBtn) cloneBtn.disabled = false;
                });
            },
            deleteAllDietItems() {
              if (!this.dietName) return;
              if (!confirm(`Delete all items for ${this.dietName}? This cannot be undone.`)) {
                return;
              }
              const status = document.getElementById("diet-items-status");
              const deleteBtn = document.getElementById("diet-items-delete-all");
              if (deleteBtn) deleteBtn.disabled = true;
              if (status) status.textContent = "Deleting all items...";
              fetch("/api/diet", {
                method: "DELETE",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ diet_name: this.dietName, delete_all: true })
              })
                .then((response) => {
                  if (!response.ok) {
                    throw new Error(`Request failed with ${response.status}`);
                  }
                  return response.json();
                })
                .then(() => {
                  window.location.href = "/";
                })
                .catch((error) => {
                  if (status) status.textContent = `Failed to delete all items: ${error.message}`;
                })
                .finally(() => {
                  if (deleteBtn) deleteBtn.disabled = false;
                });
            },
            rowStyle(row, col = null) {
              if (!row || !row.color) return '';
              const alpha = col === "Name" || col === "quantity" ? 1 : 0.5;
              return `background-color: ${toRgba(row.color, alpha)};`;
            }
        })
    })
</script>

<script>
    document.addEventListener('keydown', (event) => {
        if (event.key !== "Enter" && event.key !== "Escape") {
            return;
        }
        if (window.Alpine?.store) {
            const dietStore = Alpine.store('diet');
            if (dietStore?.isEditing) {
                dietStore.stopEdit(true);
            }
        }
    });
</script>

<script type="module">
  const params = new URLSearchParams(window.location.search);
  const dietName = params.get("diet_name");

  const foodsResponse = await fetch("/api/foods", { credentials: "same-origin" });
  const foodsList = await foodsResponse.json();
  const foods = {};
  if (Array.isArray(foodsList)) {
    foodsList.forEach((food) => {
      if (food && food.fdc_id != null) {
        foods[food.fdc_id] = food;
      }
    });
  }
  let dietItems = [];
  let dietItemNutritionList = [];
  let selectedColumns = [];
  let user = null;
  

  function fetchDiet() {
    return fetch(`/api/diets/${encodeURIComponent(dietName)}`, {
      credentials: "same-origin"
    }).then(res => res.json());
  }

  function buildColumns(rawColumns, selected) {
    const requiredColumns = ["diet_name", "fdc_id", "sort_order", "color", "Name", "quantity"];
    const selectedSet = new Set(selected);
    const columns = [...requiredColumns];

    rawColumns.forEach((rawcol) => {
      if (!requiredColumns.includes(rawcol) && selectedSet.has(rawcol)) {
        columns.push(rawcol);
      }
    });

    return columns;
  }

  async function loadUser() {
    const response = await fetch("/api/users/me", { credentials: "same-origin" });
    if (!response.ok) {
      throw new Error(`Request failed with ${response.status}`);
    }
    const user = await response.json();
    return user;
  }

  user = await loadUser();
  selectedColumns = user.settings.diet_columns;

  dietItems = await fetchDiet();

  async function loadRda() {
    const response = await fetch("/api/rda", { credentials: "same-origin" });
    if (!response.ok) {
      throw new Error(`Request failed with ${response.status}`);
    }
    const rows = await response.json();
    const map = {};
    if (Array.isArray(rows)) {
      rows.forEach((row) => {
        const nutrientRaw = row?.nutrient ?? row?.Nutrient ?? row?.NUTRIENT;
        const valueRaw = row?.value ?? row?.Value ?? row?.VALUE;
        const nutrient = String(nutrientRaw || "").trim();
        const value = Number(valueRaw);
        if (nutrient && Number.isFinite(value)) {
          map[nutrient] = value;
        }
      });
    }
    return map;
  }

  async function loadUl() {
    const response = await fetch("/api/ul", { credentials: "same-origin" });
    if (!response.ok) {
      throw new Error(`Request failed with ${response.status}`);
    }
    const rows = await response.json();
    const map = {};
    if (Array.isArray(rows)) {
      rows.forEach((row) => {
        const nutrientRaw = row?.nutrient ?? row?.Nutrient ?? row?.NUTRIENT;
        const valueRaw = row?.value ?? row?.Value ?? row?.VALUE;
        const nutrient = String(nutrientRaw || "").trim();
        const value = Number(valueRaw);
        if (nutrient && Number.isFinite(value)) {
          map[nutrient] = value;
        }
      });
    }
    return map;
  }
  
  // Calculate nutrition for each diet item
  dietItems.forEach(item => {
    let food = foods[item.fdc_id];
    dietItemNutritionList.push(calculateDietNutrition(food, item));
  });



  const dietStore = Alpine.store('diet');
  dietStore.foodsMap = foods || {};
  dietStore.foodsList = Object.values(foods || {});
  dietStore.dietItemNutritionList = dietStore.ensureRowKeys(dietItemNutritionList);
  dietStore.columns = buildColumns(Object.keys(dietItemNutritionList[0]), selectedColumns);
  dietStore.dietName = dietName || "";
  dietStore.hideRdaUlValues = Boolean(user.settings?.diet_hide_rda_ul_values);
  dietStore.rdaThreshold = Number.isFinite(Number(user.settings?.diet_rda_threshold))
    ? Number(user.settings.diet_rda_threshold)
    : null;
  dietStore.ulThreshold = Number.isFinite(Number(user.settings?.diet_ul_threshold))
    ? Number(user.settings.diet_ul_threshold)
    : null;
  try {
    dietStore.rdaByNutrient = await loadRda();
    dietStore.ulByNutrient = await loadUl();
  } catch (error) {
    console.error("Failed to load RDA/UL:", error);
  }
  dietStore.dietName = dietName || "";

</script>



{% endblock %}
